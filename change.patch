diff --git a/exampleConfig.js b/exampleConfig.js
index 169dd80..d61298d 100644
--- a/exampleConfig.js
+++ b/exampleConfig.js
@@ -14,7 +14,7 @@ Optional Variables:
   graphiteProtocol: either 'text' or 'pickle' [default: 'text']
   backends:         an array of backends to load. Each backend must exist
                     by name in the directory backends/. If not specified,
-                    the default graphite backend will be loaded. 
+                    the default graphite backend will be loaded.
                     * example for console and graphite:
                     [ "./backends/console", "./backends/graphite" ]
 
@@ -60,7 +60,7 @@ Optional Variables:
     log:            location of log file for frequent keys [default: STDOUT]
   deleteIdleStats:  don't send values to graphite for inactive counters, sets, gauges, or timers
                     as opposed to sending 0.  For gauges, this unsets the gauge (instead of sending
-                    the previous value). Can be individually overriden. [default: false]
+                    the previous value). Can be individually overridden. [default: false]
   deleteGauges:     don't send values to graphite for inactive gauges, as opposed to sending the previous value [default: false]
   deleteTimers:     don't send values to graphite for inactive timers, as opposed to sending 0 [default: false]
   deleteSets:       don't send values to graphite for inactive sets, as opposed to sending 0 [default: false]
@@ -71,6 +71,10 @@ Optional Variables:
                     If disabled, it is up to the backends to sanitize keynames
                     as appropriate per their storage requirements.
 
+  calculatedTimerMetrics: List of timer metrics that will be sent. Default will send all metrics.
+                          To filter on percents and top percents: append '_percent' to the metric name.
+                          Example: calculatedTimerMetrics: ['count', 'median', 'upper_percent', 'histogram']
+
   console:
     prettyprint:    whether to prettyprint the console backend
                     output [true or false, default: true]
diff --git a/lib/process_metrics.js b/lib/process_metrics.js
index 8228f98..3853606 100644
--- a/lib/process_metrics.js
+++ b/lib/process_metrics.js
@@ -1,6 +1,6 @@
 /*jshint node:true, laxcomma:true */
 
-var process_metrics = function (metrics, flushInterval, ts, flushCallback) {
+const process_metrics = function (metrics, calculatedTimerMetrics, flushInterval, ts, flushCallback) {
     var starttime = Date.now();
     var key;
     var counter_rates = {};
@@ -132,7 +132,7 @@ var process_metrics = function (metrics, flushInterval, ts, flushCallback) {
 
       }
 
-      timer_data[key] = current_timer_data;
+      timer_data[key] = filter_timer_metrics(current_timer_data, calculatedTimerMetrics);
     }
 
     statsd_metrics["processing_time"] = (Date.now() - starttime);
@@ -144,4 +144,20 @@ var process_metrics = function (metrics, flushInterval, ts, flushCallback) {
     flushCallback(metrics);
   };
 
+var filter_timer_metrics = function (currentTimerMetrics, calculatedTimerMetrics) {
+  if (!Array.isArray(calculatedTimerMetrics) || calculatedTimerMetrics.length == 0) {
+    return currentTimerMetrics;
+  } else {
+    return Object.keys(currentTimerMetrics)
+      .filter((key) => {
+        // Generalizes filtering percent metrics by cleaning key from <metric>_<number> to <metric>_percent
+        var cleaned_key = key.replace(/_(top)?\d+$/, "_percent")
+        return calculatedTimerMetrics.indexOf(cleaned_key) !== -1;
+      })
+      .reduce((obj, key) => {
+        obj[key] = currentTimerMetrics[key];
+        return obj;
+      }, {});
+  }
+}
 exports.process_metrics = process_metrics;
diff --git a/stats.js b/stats.js
index 96bd13f..9c170ec 100644
--- a/stats.js
+++ b/stats.js
@@ -148,7 +148,7 @@ function flushMetrics() {
     }
   });
 
-  pm.process_metrics(metrics_hash, flushInterval, time_stamp, function emitFlush(metrics) {
+  pm.process_metrics(metrics_hash, conf.calculatedTimerMetrics, flushInterval, time_stamp, function emitFlush(metrics) {
     backendEvents.emit('flush', time_stamp, metrics);
   });
 
diff --git a/test/graphite_tests_filters.js b/test/graphite_tests_filters.js
new file mode 100644
index 0000000..8de66d7
--- /dev/null
+++ b/test/graphite_tests_filters.js
@@ -0,0 +1,180 @@
+var fs       = require('fs'),
+    net      = require('net'),
+    temp     = require('temp'),
+    spawn    = require('child_process').spawn,
+    util     = require('util'),
+    urlparse = require('url').parse,
+    _        = require('underscore'),
+    dgram    = require('dgram'),
+    qsparse  = require('querystring').parse,
+    http     = require('http');
+
+
+var writeconfig = function(text, worker, cb, obj){
+  temp.open({suffix: '-statsdconf.js'}, function(err, info) {
+    if (err) throw err;
+    fs.writeSync(info.fd, text);
+    fs.close(info.fd, function(err) {
+      if (err) throw err;
+      worker(info.path, cb, obj);
+    });
+  });
+}
+
+var statsd_send = function(data,sock,host,port,cb){
+  send_data = new Buffer(data);
+  sock.send(send_data,0,send_data.length,port,host,function(err,bytes){
+    if (err) {
+      throw err;
+    }
+    cb();
+  });
+}
+
+// keep collecting data until a specified timeout period has elapsed
+// this will let us capture all data chunks so we don't miss one
+var collect_for = function(server,timeout,cb){
+  var received = [];
+  var in_flight = 0;
+  var timed_out = false;
+  var collector = function(req,res){
+    in_flight += 1;
+    var body = '';
+    req.on('data',function(data){ body += data; });
+    req.on('end',function(){
+      received = received.concat(body.split("\n"));
+      in_flight -= 1;
+      if((in_flight < 1) && timed_out){
+        server.removeListener('request',collector);
+        cb(received);
+      }
+    });
+  }
+
+  setTimeout(function (){
+    timed_out = true;
+    if((in_flight < 1)) {
+      server.removeListener('connection',collector);
+      cb(received);
+    }
+  },timeout);
+
+  server.on('connection',collector);
+}
+module.exports = {
+  setUp: function (callback) {
+    this.testport = 31337;
+    this.myflush = 200;
+    var configfile = "{graphService: \"graphite\"\n\
+               ,  batch: 200 \n\
+               ,  flushInterval: " + this.myflush + " \n\
+               ,  percentThreshold: 90\n\
+               ,  calculatedTimerMetrics: ['count_ps', 'count', 'count_percent', 'mean_percent', 'histogram']\n\
+               ,  histogram: [ { metric: \"a_test_value\", bins: [1000] } ]\n\
+               ,  port: 8125\n\
+               ,  dumpMessages: false \n\
+               ,  debug: false\n\
+               ,  graphite: { legacyNamespace: false }\n\
+               ,  graphitePort: " + this.testport + "\n\
+               ,  graphiteHost: \"127.0.0.1\"}";
+
+    this.acceptor = net.createServer();
+    this.acceptor.listen(this.testport);
+    this.sock = dgram.createSocket('udp4');
+
+    this.server_up = true;
+    this.ok_to_die = false;
+    this.exit_callback_callback = process.exit;
+
+    writeconfig(configfile,function(path, cb, obj){
+      obj.path = path;
+      obj.server = spawn('node',['stats.js', path]);
+      obj.exit_callback = function (code) {
+        obj.server_up = false;
+        if(!obj.ok_to_die){
+          console.log('node server unexpectedly quit with code: ' + code);
+          process.exit(1);
+        }
+        else {
+          obj.exit_callback_callback();
+        }
+      };
+      obj.server.on('exit', obj.exit_callback);
+      obj.server.stderr.on('data', function (data) {
+        console.log('stderr: ' + data.toString().replace(/\n$/,''));
+      });
+      /*
+      obj.server.stdout.on('data', function (data) {
+        console.log('stdout: ' + data.toString().replace(/\n$/,''));
+      });
+      */
+      obj.server.stdout.on('data', function (data) {
+        // wait until server is up before we finish setUp
+        if (data.toString().match(/server is up/)) {
+          cb();
+        }
+      });
+
+    },callback,this);
+  },
+  tearDown: function (callback) {
+    this.sock.close();
+    this.acceptor.close();
+    this.ok_to_die = true;
+    if(this.server_up){
+      this.exit_callback_callback = callback;
+      this.server.kill();
+    } else {
+      callback();
+    }
+  },
+
+  timers_are_valid: function (test) {
+    test.expect(11);
+
+    var testvalue = 100;
+    var me = this;
+    this.acceptor.once('connection', function(c){
+      statsd_send('a_test_value:' + testvalue + '|ms',me.sock,'127.0.0.1',8125,function(){
+        collect_for(me.acceptor,me.myflush*2,function(strings){
+          test.ok(strings.length > 0,'should receive some data');
+          var hashes = _.map(strings, function(x) {
+            var chunks = x.split(' ');
+            var data = {};
+            data[chunks[0]] = chunks[1];
+            return data;
+          });
+          var numstat_test = function(post){
+            var mykey = 'stats.statsd.numStats';
+            return _.include(_.keys(post),mykey) && (post[mykey] == 5);
+          };
+          test.ok(_.any(hashes,numstat_test), 'stats.statsd.numStats should be 5');
+
+          var testtimervalue_test = function(post){
+            var mykey = 'stats.timers.a_test_value.mean_90';
+            return _.include(_.keys(post),mykey) && (post[mykey] == testvalue);
+          };
+          var testtimerhistogramvalue_test = function(post){
+            var mykey = 'stats.timers.a_test_value.histogram.bin_1000';
+            return _.include(_.keys(post),mykey) && (post[mykey] == 1);
+          };
+          test.ok(_.any(hashes,testtimerhistogramvalue_test), 'stats.timers.a_test_value.histogram.bin_1000 should be 1');
+          test.ok(_.any(hashes,testtimervalue_test), 'stats.timers.a_test_value.mean_90 should be ' + testvalue);
+
+          var count_test = function(post, metric){
+            var mykey = 'stats.timers.a_test_value.' + metric;
+            return _.first(_.filter(_.pluck(post, mykey), function (e) { return e; }));
+          };
+          test.equals(count_test(hashes, 'count_ps'), 5, 'count_ps should be 5');
+          test.equals(count_test(hashes, 'count'), 1, 'count should be 1');
+          test.equals(count_test(hashes, 'count_90'), 1, 'count_90 should be 1');
+          test.equals(count_test(hashes, 'sum'), null, 'sum should be null');
+          test.equals(count_test(hashes, 'sum_squares'), null, 'sum_squares should be null');
+          test.equals(count_test(hashes, 'sum_90'), null, 'sum_90 should be null');
+          test.equals(count_test(hashes, 'sum_squares_90'), null, 'sum_squares_90 should be null');
+          test.done();
+        });
+      });
+    });
+  },
+}
diff --git a/test/process_metrics_tests.js b/test/process_metrics_tests.js
index 6a5b182..7ddae70 100644
--- a/test/process_metrics_tests.js
+++ b/test/process_metrics_tests.js
@@ -11,6 +11,7 @@ module.exports = {
     var timer_counters = {};
     var sets = {};
     var pctThreshold = null;
+    var calculatedTimerMetrics = [];
 
     this.metrics = {
       counters: counters,
@@ -25,14 +26,14 @@ module.exports = {
   counters_has_stats_count: function(test) {
     test.expect(1);
     this.metrics.counters['a'] = 2;
-    pm.process_metrics(this.metrics, 1000, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 1000, this.time_stamp, function(){});
     test.equal(2, this.metrics.counters['a']);
     test.done();
   },
   counters_has_correct_rate: function(test) {
     test.expect(1);
     this.metrics.counters['a'] = 2;
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     test.equal(20, this.metrics.counter_rates['a']);
     test.done();
   },
@@ -40,7 +41,7 @@ module.exports = {
     test.expect(1);
     this.metrics.timers['a'] = [];
     this.metrics.timer_counters['a'] = 0;
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     //potentially a cleaner way to check this
     test.equal(undefined, this.metrics.counter_rates['a']);
     test.done();
@@ -49,7 +50,7 @@ module.exports = {
     test.expect(9);
     this.metrics.timers['a'] = [100];
     this.metrics.timer_counters['a'] = 1;
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(0, timer_data.std);
     test.equal(100, timer_data.upper);
@@ -62,11 +63,49 @@ module.exports = {
     test.equal(100, timer_data.median);
     test.done();
   },
-    timers_multiple_times: function(test) {
+  timer_single_time_with_one_filter: function(test) {
+    test.expect(10);
+    this.metrics.timers['a'] = [100];
+    this.metrics.timer_counters['a'] = 1;
+    var filter = ['upper', 'lower', 'count', 'count_ps', 'sum', 'sum_squares', 'mean', 'median']
+    pm.process_metrics(this.metrics, filter, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(8, Object.keys(timer_data).length)
+    test.equal(null, timer_data.std);
+    test.equal(100, timer_data.upper);
+    test.equal(100, timer_data.lower);
+    test.equal(1, timer_data.count);
+    test.equal(10, timer_data.count_ps);
+    test.equal(100, timer_data.sum);
+    test.equal(100 * 100, timer_data.sum_squares);
+    test.equal(100, timer_data.mean);
+    test.equal(100, timer_data.median);
+    test.done();
+  },
+  timer_single_time_multiple_filter: function(test) {
+    test.expect(10);
+    this.metrics.timers['a'] = [100];
+    this.metrics.timer_counters['a'] = 1;
+    var filter = ['upper', 'lower', 'count_ps', 'sum_squares']
+    pm.process_metrics(this.metrics, filter, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(4, Object.keys(timer_data).length)
+    test.equal(null, timer_data.std);
+    test.equal(100, timer_data.upper);
+    test.equal(100, timer_data.lower);
+    test.equal(null, timer_data.count);
+    test.equal(10, timer_data.count_ps);
+    test.equal(null, timer_data.sum);
+    test.equal(100 * 100, timer_data.sum_squares);
+    test.equal(null, timer_data.mean);
+    test.equal(null, timer_data.median);
+    test.done();
+  },
+  timers_multiple_times: function(test) {
     test.expect(9);
     this.metrics.timers['a'] = [100, 200, 300];
     this.metrics.timer_counters['a'] = 3;
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(81.64965809277261, timer_data.std);
     test.equal(300, timer_data.upper);
@@ -75,17 +114,36 @@ module.exports = {
     test.equal(30, timer_data.count_ps);
     test.equal(600, timer_data.sum);
     test.equal(100 * 100 + 200 * 200 + 300 * 300,
-               timer_data.sum_squares);
+      timer_data.sum_squares);
+    test.equal(200, timer_data.mean);
+    test.equal(200, timer_data.median);
+    test.done();
+  },
+  timers_multiple_times_with_calculated_timer_metrics: function(test) {
+    test.expect(9);
+    this.metrics.timers['a'] = [100, 200, 300];
+    this.metrics.timer_counters['a'] = 3;
+    var calculatedTimerMetrics =  ['std', 'count', 'sum_squares', 'mean', 'median']
+    pm.process_metrics(this.metrics, calculatedTimerMetrics, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(81.64965809277261, timer_data.std);
+    test.equal(null, timer_data.upper);
+    test.equal(null, timer_data.lower);
+    test.equal(3, timer_data.count);
+    test.equal(null, timer_data.count_ps);
+    test.equal(null, timer_data.sum);
+    test.equal(100 * 100 + 200 * 200 + 300 * 300,
+      timer_data.sum_squares);
     test.equal(200, timer_data.mean);
     test.equal(200, timer_data.median);
     test.done();
   },
-    timers_single_time_single_percentile: function(test) {
+  timers_single_time_single_percentile: function(test) {
     test.expect(4);
     this.metrics.timers['a'] = [100];
     this.metrics.timer_counters['a'] = 1;
     this.metrics.pctThreshold = [90];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(100, timer_data.mean_90);
     test.equal(100, timer_data.upper_90);
@@ -93,45 +151,94 @@ module.exports = {
     test.equal(100 * 100, timer_data.sum_squares_90);
     test.done();
   },
-    timers_single_time_multiple_percentiles: function(test) {
-    test.expect(9);
+  timers_single_time_single_percentile_with_calculated_timer_metrics: function(test) {
+    test.expect(4);
+    this.metrics.timers['a'] = [100];
+    this.metrics.timer_counters['a'] = 1;
+    this.metrics.pctThreshold = [90];
+    pm.process_metrics(this.metrics, ['upper_percent', 'sum_squares_percent'], 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(null, timer_data.mean_90);
+    test.equal(100, timer_data.upper_90);
+    test.equal(null, timer_data.sum_90);
+    test.equal(100 * 100, timer_data.sum_squares_90);
+    test.done();
+  },
+  timers_single_time_multiple_percentiles: function(test) {
+    test.expect(10);
     this.metrics.timers['a'] = [100];
     this.metrics.timer_counters['a'] = 1;
     this.metrics.pctThreshold = [90, 80];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(1, timer_data.count_90);
     test.equal(100, timer_data.mean_90);
     test.equal(100, timer_data.upper_90);
     test.equal(100, timer_data.sum_90);
     test.equal(100 * 100, timer_data.sum_squares_90);
+    test.equal(1, timer_data.count_80);
     test.equal(100, timer_data.mean_80);
     test.equal(100, timer_data.upper_80);
     test.equal(100, timer_data.sum_80);
     test.equal(100 * 100, timer_data.sum_squares_80);
     test.done();
   },
-    timers_multiple_times_single_percentiles: function(test) {
+  timers_single_time_multiple_percentiles_with_calculated_timer_metrics: function(test) {
+    test.expect(10);
+    this.metrics.timers['a'] = [100];
+    this.metrics.timer_counters['a'] = 1;
+    this.metrics.pctThreshold = [90, 80];
+    var calculatedTimerMetrics = ['mean_percent', 'sum_percent']
+    pm.process_metrics(this.metrics, calculatedTimerMetrics, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(null, timer_data.count_90);
+    test.equal(100, timer_data.mean_90);
+    test.equal(null, timer_data.upper_90);
+    test.equal(100, timer_data.sum_90);
+    test.equal(null, timer_data.sum_squares_90);
+    test.equal(null, timer_data.count_80);
+    test.equal(100, timer_data.mean_80);
+    test.equal(null, timer_data.upper_80);
+    test.equal(100, timer_data.sum_80);
+    test.equal(null, timer_data.sum_squares_80);
+    test.done();
+  },
+  timers_multiple_times_single_percentiles: function(test) {
     test.expect(5);
     this.metrics.timers['a'] = [100, 200, 300];
     this.metrics.timer_counters['a'] = 3;
     this.metrics.pctThreshold = [90];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(3, timer_data.count_90);
     test.equal(200, timer_data.mean_90);
     test.equal(300, timer_data.upper_90);
     test.equal(600, timer_data.sum_90);
     test.equal(100 * 100 + 200 * 200 + 300 * 300,
-               timer_data.sum_squares_90);
+      timer_data.sum_squares_90);
+    test.done();
+  },
+  timers_multiple_times_single_percentiles_with_calculated_timer_metrics: function(test) {
+    test.expect(5);
+    this.metrics.timers['a'] = [100, 200, 300];
+    this.metrics.timer_counters['a'] = 3;
+    this.metrics.pctThreshold = [90];
+    var filter = ['count_percent', 'mean_percent', 'upper_percent']
+    pm.process_metrics(this.metrics, filter, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(3, timer_data.count_90);
+    test.equal(200, timer_data.mean_90);
+    test.equal(300, timer_data.upper_90);
+    test.equal(null, timer_data.sum_90);
+    test.equal(null, timer_data.sum_squares_90);
     test.done();
   },
-    timers_multiple_times_multiple_percentiles: function(test) {
+  timers_multiple_times_multiple_percentiles: function(test) {
     test.expect(11);
     this.metrics.timers['a'] = [100, 200, 300];
     this.metrics.timer_counters['a'] = 3;
     this.metrics.pctThreshold = [90, 80];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(3, timer_data.count);
     test.equal(3, timer_data.count_90);
@@ -139,22 +246,45 @@ module.exports = {
     test.equal(300, timer_data.upper_90);
     test.equal(600, timer_data.sum_90);
     test.equal(100 * 100 + 200 * 200 + 300 * 300,
-               timer_data.sum_squares_90);
+      timer_data.sum_squares_90);
 
     test.equal(2, timer_data.count_80);
     test.equal(150, timer_data.mean_80);
     test.equal(200, timer_data.upper_80);
     test.equal(300, timer_data.sum_80);
     test.equal(100 * 100 + 200 * 200,
-               timer_data.sum_squares_80);
+      timer_data.sum_squares_80);
+    test.done();
+  },
+  timers_multiple_times_multiple_percentiles_with_calculated_timer_metrics: function(test) {
+    test.expect(11);
+    this.metrics.timers['a'] = [100, 200, 300];
+    this.metrics.timer_counters['a'] = 3;
+    this.metrics.pctThreshold = [90, 80];
+    pm.process_metrics(this.metrics, ['count_percent', 'sum_percent', 'sum_squares_percent'], 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(null, timer_data.count);
+    test.equal(3, timer_data.count_90);
+    test.equal(null, timer_data.mean_90);
+    test.equal(null, timer_data.upper_90);
+    test.equal(600, timer_data.sum_90);
+    test.equal(100 * 100 + 200 * 200 + 300 * 300,
+      timer_data.sum_squares_90);
+
+    test.equal(2, timer_data.count_80);
+    test.equal(null, timer_data.mean_80);
+    test.equal(null, timer_data.upper_80);
+    test.equal(300, timer_data.sum_80);
+    test.equal(100 * 100 + 200 * 200,
+      timer_data.sum_squares_80);
     test.done();
   },
-    timers_sampled_times: function(test) {
+  timers_sampled_times: function(test) {
     test.expect(8);
     this.metrics.timers['a'] = [100, 200, 300];
     this.metrics.timer_counters['a'] = 50;
     this.metrics.pctThreshold = [90, 80];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(50, timer_data.count);
     test.equal(500, timer_data.count_ps);
@@ -166,7 +296,45 @@ module.exports = {
     test.equal(300, timer_data.sum_80);
     test.done();
   }, // check if the correct settings are being applied. as well as actual counts
-    timers_histogram: function (test) {
+  timers_histogram: function (test) {
+    test.expect(13);
+    this.metrics.timers['a'] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
+    this.metrics.timers['abc'] = [0.1234, 2.89, 4, 6, 8];
+    this.metrics.timers['foo'] = [0, 2, 4, 6, 8];
+    this.metrics.timers['barbazfoobar'] = [0, 2, 4, 6, 8];
+    this.metrics.timers['bar.bazfoobar.abc'] = [0, 2, 4, 6, 8];
+    this.metrics.timers['xyz'] = [0, 2, 4, 6, 8];
+    this.metrics.histogram = [ { metric: 'foo', bins: [] },
+      { metric: 'abcd', bins: [ 1, 5, 'inf'] },
+      { metric: 'abc', bins: [ 1, 2.21, 'inf'] },
+      { metric: 'a', bins: [ 1, 2] } ];
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data;
+    // nothing matches the 'abcd' calculatedTimerMetrics, so nothing has bin_5
+    test.equal(undefined, timer_data['a']['histogram']['bin_5']);
+    test.equal(undefined, timer_data['abc']['histogram']['bin_5']);
+
+    // check that 'a' got the right calculatedTimerMetrics and numbers
+    test.equal(0, timer_data['a']['histogram']['bin_1']);
+    test.equal(1, timer_data['a']['histogram']['bin_2']);
+    test.equal(undefined, timer_data['a']['histogram']['bin_inf']);
+
+    // only 'abc' should have a bin_inf; also check all its counts,
+    // and make sure it has no other bins
+    test.equal(1, timer_data['abc']['histogram']['bin_1']);
+    test.equal(0, timer_data['abc']['histogram']['bin_2_21']);
+    test.equal(4, timer_data['abc']['histogram']['bin_inf']);
+    test.equal(3, _.size(timer_data['abc']['histogram']));
+
+    // these all have histograms disabled ('foo' explicitly, rest implicitly)
+    test.equal(undefined, timer_data['foo']['histogram']);
+    test.equal(undefined, timer_data['barbazfoobar']['histogram']);
+    test.equal(undefined, timer_data['bar.bazfoobar.abc']['histogram']);
+    test.equal(undefined, timer_data['xyz']['histogram']);
+
+    test.done();
+  },
+  timers_histogram_with_calculated_timer_metrics: function (test) {
     test.expect(13);
     this.metrics.timers['a'] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     this.metrics.timers['abc'] = [0.1234, 2.89, 4, 6, 8];
@@ -175,16 +343,16 @@ module.exports = {
     this.metrics.timers['bar.bazfoobar.abc'] = [0, 2, 4, 6, 8];
     this.metrics.timers['xyz'] = [0, 2, 4, 6, 8];
     this.metrics.histogram = [ { metric: 'foo', bins: [] },
-                               { metric: 'abcd', bins: [ 1, 5, 'inf'] },
-                               { metric: 'abc', bins: [ 1, 2.21, 'inf'] },
-                               { metric: 'a', bins: [ 1, 2] } ];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+      { metric: 'abcd', bins: [ 1, 5, 'inf'] },
+      { metric: 'abc', bins: [ 1, 2.21, 'inf'] },
+      { metric: 'a', bins: [ 1, 2] } ];
+    pm.process_metrics(this.metrics, ['histogram'], 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data;
-    // nothing matches the 'abcd' config, so nothing has bin_5
+    // nothing matches the 'abcd' calculatedTimerMetrics, so nothing has bin_5
     test.equal(undefined, timer_data['a']['histogram']['bin_5']);
     test.equal(undefined, timer_data['abc']['histogram']['bin_5']);
 
-    // check that 'a' got the right config and numbers
+    // check that 'a' got the right calculatedTimerMetrics and numbers
     test.equal(0, timer_data['a']['histogram']['bin_1']);
     test.equal(1, timer_data['a']['histogram']['bin_2']);
     test.equal(undefined, timer_data['a']['histogram']['bin_inf']);
@@ -204,41 +372,88 @@ module.exports = {
 
     test.done();
   },
-    timers_single_time_single_top_percentile: function(test) {
+  timers_single_time_single_top_percentile: function(test) {
     test.expect(3);
     this.metrics.timers['a'] = [100];
     this.metrics.pctThreshold = [-10];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(100, timer_data.mean_top10);
     test.equal(100, timer_data.lower_top10);
     test.equal(100, timer_data.sum_top10);
     test.done();
   },
-    timers_multiple_times_single_top_percentile: function(test) {
+  timers_single_time_single_top_percentile_with_calculated_timer_metrics: function(test) {
+    test.expect(3);
+    this.metrics.timers['a'] = [100];
+    this.metrics.pctThreshold = [-10];
+    pm.process_metrics(this.metrics, ['lower_percent'], 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(null, timer_data.mean_top10);
+    test.equal(100, timer_data.lower_top10);
+    test.equal(null, timer_data.sum_top10);
+    test.done();
+  },
+  timers_multiple_times_single_top_percentile: function(test) {
     test.expect(3);
     this.metrics.timers['a'] = [10, 10, 10, 10, 10, 10, 10, 10, 100, 200];
     this.metrics.pctThreshold = [-20];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(150, timer_data.mean_top20);
     test.equal(100, timer_data.lower_top20);
     test.equal(300, timer_data.sum_top20);
     test.done();
   },
-    statsd_metrics_exist: function(test) {
+  timers_multiple_times_single_top_percentile_with_calculated_timer_metrics: function(test) {
+    test.expect(3);
+    this.metrics.timers['a'] = [10, 10, 10, 10, 10, 10, 10, 10, 100, 200];
+    this.metrics.pctThreshold = [-20];
+    pm.process_metrics(this.metrics, ['mean_percent', 'sum_percent'], 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(150, timer_data.mean_top20);
+    test.equal(null, timer_data.lower_top20);
+    test.equal(300, timer_data.sum_top20);
+    test.done();
+  },
+  statsd_metrics_exist: function(test) {
     test.expect(1);
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
     statsd_metrics = this.metrics.statsd_metrics;
     test.notEqual(undefined, statsd_metrics["processing_time"]);
     test.done();
   },
-    timers_multiple_times_even: function(test) {
+  timers_multiple_times_even: function(test) {
+    test.expect(1);
+    this.metrics.timers['a'] = [300, 200, 400, 100];
+    pm.process_metrics(this.metrics, this.calculatedTimerMetrics, 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(250, timer_data.median);
+    test.done();
+  },
+  timers_multiple_times_even_with_calculated_timer_metrics: function(test) {
     test.expect(1);
     this.metrics.timers['a'] = [300, 200, 400, 100];
-    pm.process_metrics(this.metrics, 100, this.time_stamp, function(){});
+    pm.process_metrics(this.metrics, ['median'], 100, this.time_stamp, function(){});
     timer_data = this.metrics.timer_data['a'];
     test.equal(250, timer_data.median);
     test.done();
+  },
+  timers_with_invalid_filter: function(test) {
+    test.expect(9);
+    this.metrics.timers['a'] = [100];
+    this.metrics.timer_counters['a'] = 1;
+    pm.process_metrics(this.metrics, 'not a valid filter', 100, this.time_stamp, function(){});
+    timer_data = this.metrics.timer_data['a'];
+    test.equal(0, timer_data.std);
+    test.equal(100, timer_data.upper);
+    test.equal(100, timer_data.lower);
+    test.equal(1, timer_data.count);
+    test.equal(10, timer_data.count_ps);
+    test.equal(100, timer_data.sum);
+    test.equal(100 * 100, timer_data.sum_squares);
+    test.equal(100, timer_data.mean);
+    test.equal(100, timer_data.median);
+    test.done();
   }
 }
